#!/usr/bin/env python
import argparse
import errno
import subprocess
import sys
import urllib
from qmctl_class import QMCTL

def perror(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def create_argument_parser(description):
    """Create and configure the argument parser for the CLI."""
    parser = ArgumentParserWithDefaults(
        prog="qmctl",
        description=description,
        formatter_class=argparse.RawTextHelpFormatter,
    )
    configure_arguments(parser)
    return parser


class ArgumentParserWithDefaults(argparse.ArgumentParser):
    def add_argument(self, *args, help=None, default=None, completer=None, **kwargs):
        if help is not None:
            kwargs['help'] = help
        if default is not None and args[0] != '-h':
            kwargs['default'] = default
            if help is not None and help != "==SUPPRESS==":
                kwargs['help'] += f' (default: {default})'
        action = super().add_argument(*args, **kwargs)
        if completer is not None:
            action.completer = completer
        return action

 
def configure_arguments(parser):
    """Configure the command-line arguments for the parser."""
    # This group ensures that the user can't specify both -v and -q
    verbosity_group = parser.add_mutually_exclusive_group()

    # Add a verbose argument
    verbosity_group.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output."
    )


def init_cli():
    """Initialize the QMCTL CLI and parse command line arguments."""
    description = get_description()
    parser = create_argument_parser(description)
    configure_subcommands(parser)
    args = parse_arguments(parser)
    post_parse_setup(args)
    return parser, args

def get_description():
    """Return the description of the QMCTL tool."""
    return """\
QmCTL: Command Line Interface for QMCTL
"""


def configure_subcommands(parser):
    """Add subcommand parsers to the main argument parser."""
    subparsers = parser.add_subparsers(dest="subcommand")
    subparsers.required = False
    show(subparsers)
    exec(subparsers)
    execin(subparsers)
    cp(subparsers)


def show(subparsers):
    parser = subparsers.add_parser("show", help="Show container info")
    parser.add_argument(
        "topic",
        nargs="?",
        default="container",
        choices=[
            "container",
            "unix-domain-sockets",
            "shared-memory",
            "resources",
            "available-devices",
            "namespaces",
            "all"
        ],
        help="What to show"
    )
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.set_defaults(func=handle_show_command)


def handle_show_command(args, qmctl):
        if args.topic == "unix-domain-sockets":
            qmctl.show_unix_sockets(output_json=args.json, pretty=True)
        elif args.topic == "shared-memory":
            qmctl.show_shared_memory(output_json=args.json, pretty=True)
        elif args.topic == "resources":
            qmctl.show_resources(output_json=args.json, pretty=True)
        elif args.topic == "available-devices":
            qmctl.show_available_devices(output_json=args.json, pretty=True)
        elif args.topic == "namespaces":
            qmctl.show_namespaces(output_json=args.json, pretty=True)
        elif args.topic == "all":
            print(); qmctl.show(output_json=args.json, pretty=True)
            print(); qmctl.show_unix_sockets(output_json=args.json, pretty=True)
            print(); qmctl.show_shared_memory(output_json=args.json, pretty=True)
            print(); qmctl.show_available_devices(output_json=args.json, pretty=True)
            print(); qmctl.show_namespaces(output_json=args.json, pretty=True)
        else:
            qmctl.show(output_json=args.json, pretty=True)


def exec(subparsers):
    parser = subparsers.add_parser("exec", help="Run command inside QM container")
    parser.add_argument("cmd", nargs=argparse.REMAINDER, help="Command to execute")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.set_defaults(func=handle_exec_command)


def handle_exec_command(args, qmctl):
    qmctl.exec_in_container(command=args.cmd, output_json=args.json, pretty=True)

def execin(subparsers):
    parser = subparsers.add_parser("execin", help="Run command inside a nested continer in QM")
    parser.add_argument("cmd", nargs=argparse.REMAINDER, help="Command and continer name to execute")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.set_defaults(func=handle_execin_command)

def handle_execin_command(args, qmctl):
    qmctl.execin_in_container(command=args.cmd, output_json=args.json, pretty=True)

def cp(subparsers):
    parser = subparsers.add_parser("cp", help="Copy files from and to QM")
    parser.add_argument("paths", nargs=argparse.REMAINDER, help="source and destination to copy")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.set_defaults(func=handle_cp_command)

def handle_cp_command(args, qmctl):
    qmctl.copy_in_container(paths=args.paths, output_json=args.json, pretty=True)


def parse_arguments(parser):
    """Parse command line arguments."""
    return parser.parse_args()


def post_parse_setup(args):
    """Perform additional setup after parsing arguments."""
    pass


if __name__ == "__main__":
    parser, args = init_cli()
    qmctl = QMCTL(verbose=args.verbose)
    try:
        import argcomplete

        argcomplete.autocomplete(parser)
    except Exception:
        pass

    def eprint(e, exit_code):
        perror("Error: " + str(e).strip("'\""))
        sys.exit(exit_code)


    try:
        args.func(args, qmctl)
    except AttributeError as e:
        parser.print_usage()
        perror("ramalama: requires a subcommand")
        if getattr(args, "debug", False):
            raise e
    except IndexError as e:
        eprint(e, errno.EINVAL)
    except KeyError as e:
        eprint(e, 1)
    except NotImplementedError as e:
        eprint(e, errno.ENOTSUP)
    except subprocess.CalledProcessError as e:
        eprint(e, e.returncode)
    except KeyboardInterrupt:
        sys.exit(0)
    except ConnectionError as e:
        eprint(e, errno.EINVAL)
    except ValueError as e:
        eprint(e, errno.EINVAL)
    except IOError as e:
        eprint(e, errno.EIO)
