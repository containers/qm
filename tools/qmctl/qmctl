#!/usr/bin/env python
"""A Python interface for interacting with the 'qm' container.

This module provides the QMCTL class for interacting with the 'qm'
container managed by podman. It allows for executing commands, copying
files, and inspecting various aspects of the container's state.
"""
import os
import sys
import json
import subprocess
import pty
import argparse
import errno
from collections import defaultdict


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Start of the QMCTL class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


class QMCTL:
    """Manage and interact with the qm container."""

    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Start of the QMCTL class private methods
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    def __init__(
        self,
        config_path="/usr/share/containers/systemd/qm.container",
        verbose=False,
        container_name="qm",
    ):
        """Initialize the QMCTL class.

        Args:
            config_path (str): The path to the container config file.
            verbose (bool): If True, enables verbose logging to stderr.
            container_name (str): The name of the container to interact with.
        """
        self.config_path = config_path
        self.container = container_name
        self.verbose = verbose

    def _log_path(self, action, path):
        """Log the action being performed on a path if verbose is enabled."""
        if self.verbose:
            print(f"[verbose] {action}: {path}", file=sys.stderr)

    def _print_output_and_exit(self, msg, exit_code=1):
        """Print an error message to output and exit the script."""
        self._print_output(
            {"Error": msg})
        exit(exit_code)

    def _container_exists(self, name):
        """Check if a podman container with the given name exists."""
        try:
            command = ["podman", "container", "exists", name]
            result = subprocess.run(
                command,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return result.returncode == 0
        except Exception as e:
            self._print_output_and_exit(msg=e)

    def _check_if_path_exists_and_handle_error(self, path):
        """Check if a path exists and handle the error if it does not.

        Args:
            path (str): The path to check.

        Raises:
            RuntimeError: If the path does not exist.
        """
        if not os.path.exists(path):
            msg = f"Configuration file {self.config_path} not found."
            self._print_output_and_exit(msg, exit_code=errno.ENOENT)

    def _check_if_container_exists_and_handle_error(self):
        """Check if a container exists and handle the error if it does not.

        This method uses `self.container` to check for container existence.

        Raises:
            RuntimeError: If the container does not exist.
        """
        if not self._container_exists(self.container):
            msg = f"Container '{self.container}' does not exist."
            self._print_output_and_exit(msg)

    def _check_if_any_devcie_exists_and_handle_error(self, devices):
        """Check if any device exists and handle the error if none do.

        Args:
            devices (list): A list of device paths to check.

        Raises:
            RuntimeError: If no devices are found in the list.
        """
        if not devices:
            msg = (
                "No devices specified in the container config. "
                "Please add 'AddDevice=' entries to the config file."
            )
            self._print_output_and_exit(
                {"Error": msg}
            )

    def _check_exit_if_string_in_string(self, string, substring, message):
        """Exit if a substring is found in a string.

        Args:
            string (str): The string to check.
            substring (str): The substring to look for.
            message (str): The error message to print if
            the substring is found.

        Raises:
            RuntimeError: If the substring is found in the string.
        """
        if substring in string:
            self._print_output_and_exit(
                message
            )

    def _check_result_returncode_and_output(self, result, msg):
        """Check the return code and output of the subprocess result."""
        if result.returncode != 0:
            self._print_output_and_exit(
                f"{msg} Return code: {result.returncode}, "
                f"Output: {result.stdout.strip()}")
        if not result.stdout.strip():
            self._print_output_and_exit(
                f"{msg} No output returned.")

    def _check_if_command_is_not_None(self, command, msg):
        """Check if the command is not None.

        Args:
            command: The command to check.

        Raises:
            RuntimeError: If the command is None.
        """
        if not command:
            self._print_output_and_exit(
                {"Error": msg}
            )

    def _check_and_extract_src_dst_from_paths(self, paths):
        """Check and extract source and destination paths from a list.

        Args:
            paths (list): A list containing source and destination paths.

        Returns:
            tuple: A tuple containing the source and destination paths.

        Raises:
            RuntimeError: If the paths are not provided correctly.
        """
        if not paths or len(paths) != 2:
            msg = "Please provide source and destination paths."
            self._print_output_and_exit({"Error": msg})

        src, dst = paths
        if not ((self.container + ":") in src ^ (self.container + ":") in dst):
            msg = (
                f"Provide `{self.container}:` only in source or destination"
            )
            self._print_output_and_exit({"Error": msg})

        return src, dst

    def _check_if_command_is_valid_and_get_name_and_command(
            self, command):
        self._check_if_command_is_not_None(
            command,
            "No container name provided to execute in."
        )

        if len(command) < 2:
            self._print_output_and_exit(
                {"Error": "No command provided to execute."}
            )
        return command[0], command[1:]

    def _open_config_file_strip_and_append_to_devices(self, devices):
        """Open the container config file and append device paths to a list.

        Args:
            devices (list): A list to append device paths found in the
                config file.
        """
        self._check_if_path_exists_and_handle_error(self.config_path)

        self._log_path("Reading", self.config_path)
        with open(self.config_path, "r") as file:
            for line in file:
                if line.strip().startswith("AddDevice="):
                    path = line.strip().split("=", 1)[1].lstrip("-").strip()
                    devices.append(path)

    def _run_command_for_each_device(devices, container, command):
        """Run a command for each device in the container."""
        results = {}
        for device in devices:
            command = command + [device]
            result = subprocess.run(
                command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
            results[device] = result.returncode == 0
        return results

    def _handle_subprocess_result_for_podman_exec_lsn(self, result):
        """Handle the result of a subprocess call to podman exec."""
        msg = ("Error: 'lsns' command not found inside the QM container.\n"
               "To install it, run:\n"
               "  sudo dnf --installroot=/usr/lib/qm/rootfs/ "
               "install util-linux -y")
        self._check_exit_if_string_in_string(
            result.stderr.lower(),
            "command not found",
            msg
        )

        msg = "Error: Failed to retrieve namespace info using 'lsns'."
        self._check_result_returncode_and_output(result, msg)

    def _print_output(self, data):
        """Print data as either plain text or JSON.

        Args:
            data (dict or any): The data to print.
            as_json (bool): If True, print as JSON.
            pretty (bool): If True and printing JSON, indent the output.
        """
        if not isinstance(data, dict):
            data = {"Output": data}

        if self.output_json:
            print(json.dumps(
                data,
                indent=4 if self.pretty else None
            ))
            return

        if "error" in data:
            print(data["Error"], file=sys.stderr)
        elif all(isinstance(v, bool) for v in data.values()):
            for key, value in data.items():
                status = "present in QM" if value else "missing in QM"
                print(f"{key}: {status}")
        else:
            for key, value in data.items():
                if isinstance(value, dict):
                    print(f"{key}:")
                    for sub_key, sub_val in value.items():
                        print(f"  {sub_key}: {sub_val}")
                else:
                    print(f"{key}: {value}")

    def _run_show_command_func(self, show_command_func):
        """Run a command and print its output.

        Args:
            show_command_func (callable): The function to run.
        """
        try:
            show_command_func()
        except Exception as e:
            self._print_output_and_exit(
                f"Failed to execute command: {str(e)}"
            )

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# End of the QMCTL class private methods
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    class HandleLineInContent:
        """Helper class to parse a single line of INI-style content."""

        def __init__(self, parsed, current_section=None):
            """Initialize the handler for a line in the content."""
            self.parsed = parsed
            self.current_section = current_section

        def handle(self, stripped_line):
            """Handle a line in the content based on its format."""
            if not stripped_line or stripped_line.startswith("#"):
                return
            if stripped_line.startswith("[") and stripped_line.endswith("]"):
                self.current_section = stripped_line[1:-1]
                self.parsed[self.current_section] = {}
            elif "=" in stripped_line and self.current_section:
                key, value = map(str.strip, stripped_line.split("=", 1))
                self.parsed[self.current_section][key] = value
            elif self.current_section:
                self.parsed[self.current_section][stripped_line] = True

        def get_parsed(self):
            """Return the parsed content."""
            return self.parsed

    def parse_to_dict(self, content):
        """Parse an INI-style string content into a dictionary.

        Args:
            content (str): The string content to parse.

        Returns:
            dict: A dictionary representing the parsed content.
        """
        handle_line_in_context = self.HandleLineInContent(defaultdict(dict))

        for line in content.splitlines():
            handle_line_in_context.handle(line.strip())
        return handle_line_in_context.get_parsed()

    def show_all(self, output_json=False, pretty=True):
        """Display the content of the container configuration file.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        all_show_commands_functions = [
            self.show_container,
            self.show_unix_sockets,
            self.show_shared_memory,
            self.show_resources,
            self.show_available_devices,
            self.show_namespaces,
        ]

        for func in all_show_commands_functions:
            self._run_show_command_func(
                func
            )

    def show_container(self, output_json=False, pretty=True):
        """Display the content of the container configuration file.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        self._check_if_path_exists_and_handle_error(self.config_path)

        self._log_path("Reading", self.config_path)
        with open(self.config_path, "r") as file:
            content = file.read()

        if self.output_json:
            parsed = self.parse_to_dict(content)
            self._print_output(
                {"path": self.config_path, "sections": parsed}
            )
        else:
            print(content, end="")

    def show_unix_sockets(self, output_json=False, pretty=True):
        """Show active UNIX domain sockets inside the container using 'ss'.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        try:
            result = subprocess.run(
                ["podman", "exec", self.container, "ss", "-xl"],
                capture_output=True,
                text=True,
                check=False,
            )

            self._check_exit_if_string_in_string(
                result.stderr.lower(),
                "command not found",
                ("Error: 'ss' command not found inside the QM container.\n"
                 "To install it, run:\n"
                 "  sudo dnf --installroot=/usr/lib/qm/rootfs/ "
                 "install iproute -y")
            )

            self._check_result_returncode_and_output(
                result,
                "Failed to retrieve UNIX domain sockets with 'ss -xl'."
            )

            self._print_output(
                {"UNIX domain sockets": result.stdout.strip()}
            )

        except Exception as e:
            self._print_output_and_exit({"Error": str(e)})

    def show_shared_memory(self, output_json=False, pretty=True):
        """Show shared memory segments in the container using 'ipcs'.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.exec_in_container(["ipcs"], output_json=output_json,
                               pretty=pretty)

    def show_resources(self, output_json=False, pretty=True):
        """Stream live resource usage for qm.service using systemd-cgtop.

        Note:
            This method runs until interrupted with Ctrl+C. It does not
            support JSON output directly due to its streaming nature.

        Args:
            output_json (bool): This parameter is ignored.
            pretty (bool): This parameter is ignored.
        """
        self.output_json = output_json
        self.pretty = pretty
        try:
            print(
                "[INFO] Starting systemd-cgtop stream for qm.service. "
                "Press Ctrl+C to exit.\n"
            )
            pid, fd = pty.fork()
            if pid == 0:
                os.execvp(
                    "systemd-cgtop", ["systemd-cgtop", "--batch", "qm.service"]
                )
            else:
                while True:
                    try:
                        output = os.read(fd, 1024).decode()
                        print(output, end="")
                    except OSError:
                        break
        except KeyboardInterrupt:
            msg = "KeyboardInterrupt: Exiting systemd-cgtop stream."
            self._print_output_and_exit(msg, exit_code=0)
        except Exception as e:
            self._print_output_and_exit(str(e))

    def show_available_devices(self, output_json=False, pretty=True):
        """Verify device existence specified in the container config.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        self._check_if_path_exists_and_handle_error(self.config_path)

        self._check_if_container_exists_and_handle_error()

        try:
            devices = []
            self._log_path("Reading", self.config_path)
            self._open_config_file_strip_and_append_to_devices(devices)

            self._check_if_any_devcie_exists_and_handle_error(devices)

            command = ["podman", "exec", self.container, "test", "-e"]
            results = self._run_command_for_each_device(devices,
                                                        self.container,
                                                        command)

            self._print_output(results)
        except Exception as e:
            self._print_output_and_exit(e)

    def show_namespaces(self, output_json=False, pretty=True):
        """Show namespace information inside the container using 'lsns'.

        Args:
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        try:
            result = subprocess.run(
                ["podman", "exec", self.container, "lsns"],
                capture_output=True,
                text=True,
                check=False,
            )

            self._handle_subprocess_result_for_podman_exec_lsn(result)

            self._print_output(
                {"Namespaces": result.stdout.strip()}
            )

        except Exception as e:
            self._print_output_and_exit({"Error": str(e)})

    def exec_in_container(self, command, output_json=False, pretty=True):
        """Execute a command inside the primary 'qm' container.

        Args:
            command (list): The command and its arguments to execute.
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty

        self._check_if_container_exists_and_handle_error()

        self._check_if_command_is_not_None(
            command,
            "No command provided to execute in the container."
        )

        try:
            result = subprocess.run(
                ["podman", "exec", self.container] + command,
                capture_output=True,
                text=True,
                check=False,
            )

            self._check_exit_if_string_in_string(
                result.stderr.lower(),
                "command not found",
                (f"Error: Command '{' '.join(command)}' not found in the "
                 f"container '{self.container}'.")
            )

            self._print_output(
                {"output": result.stdout.strip()}
            )

        except Exception as e:
            self._print_output_and_exit({"Error": str(e)})

    def copy_in_container(self, paths, output_json=False, pretty=True):
        """Copy files or directories between the host and the container.

        Args:
            paths (list): A list with the source and destination paths.
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        self._check_if_container_exists_and_handle_error()

        src, dst = self._check_and_extract_src_dst_from_paths(paths)

        try:
            result = subprocess.run(
                ["podman", "cp", src, dst],
                capture_output=True,
                text=True,
                check=False,
            )

            if result.stderr.lower():
                raise RuntimeError(result.stderr)

        except Exception as e:
            self._print_output_and_exit({"Error": str(e)})

    def execin_in_container(self, command, output_json=False, pretty=True):
        """Execute a command in a nested container inside the 'qm' container.

        Args:
            command (list): A list where the first element is the nested
                container name and the rest is the command to execute.
            output_json (bool): If True, format the output as JSON.
            pretty (bool): If True and output_json is True, pretty-print
                the JSON.
        """
        self.output_json = output_json
        self.pretty = pretty
        self._check_if_container_exists_and_handle_error()

        container_name, command_in_contaier = \
            self._check_if_command_is_valid_and_get_name_and_command(command)

        try:
            cmd_list = [
                "podman",
                "exec",
                self.container,
                "podman",
                "exec",
                container_name,
            ] + command_in_contaier
            result = subprocess.run(
                cmd_list, capture_output=True, text=True, check=False
            )

            if result.returncode != 0:
                cmd_str = " ".join(command)
                err_msg = (
                    f"Command '{cmd_str}' failed with Error: "
                    f"{result.stderr.strip()}"
                )
                raise RuntimeError(err_msg)

            self._print_output(
                {"output": result.stdout.strip()}
            )

        except Exception as e:
            self._print_output_and_exit({"Error": str(e)})

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# End of the QMCTL class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Start of the ArgumentParserWithDefaults class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


class ArgumentParserWithDefaults(argparse.ArgumentParser):
    """Subclass ArgumentParser to enhance help messages.

    This class automatically adds default values to the help text of
    arguments.
    """

    def add_argument(
        self, *args, help=None, default=None, completer=None, **kwargs
    ):
        """Add an argument and automatically format the help message.

        This method includes the default value in the help text.

        Args:
            *args: Positional arguments for the argument.
            help (str): The help text for the argument.
            default: The default value for the argument.
            completer: A completer for shell autocompletion.
            **kwargs: Additional keyword arguments.

        Returns:
            The Action object created by the parent class.
        """
        if default is not None and args[0] != "-h":
            if help is not None and help != "==SUPPRESS==":
                kwargs["help"] = (
                    f"{help} (default: {default})"
                )
        action = super().add_argument(*args, **kwargs)
        if completer is not None:
            action.completer = completer
        return action


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# End of the ArgumentParserWithDefaults class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Start of the SubcommandInitializer class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


class SubcommandInitializer:
    """A generic class to initialize subparsers for command-line applications.

    This class encapsulates the common logic for adding a subparser,
    defining its arguments, and setting its default function.
    """

    def __init__(self, subparsers, name, help_text, default_func,
                 args_config=None):
        """Initialize a new SubcommandInitializer instance.

        Args:
            subparsers: The subparser object from the main parser (e.g.,
                from parser.add_subparsers()).
            name (str): The name of the subcommand (e.g., "show", "run").
            help_text (str): The help string for the subcommand.
            default_func (callable): The function to be called when this
                subcommand is used. This function will receive the parsed
                arguments.
            args_config (list, optional): A list of dictionaries, where each
                dictionary defines an argument for the subparser. Each dict
                should contain keys corresponding to argparse.add_argument
                parameters (e.g., 'name', 'nargs', 'default', 'choices',
                'action', 'help'). Defaults to None (no additional arguments).
        """
        self.subparsers = subparsers
        self.name = name
        self.help_text = help_text
        self.default_func = default_func
        self.args_config = args_config if args_config is not None else []

    def initialize(self):
        """Add the subparser to the main parser and configure its arguments.

        Returns:
            argparse.ArgumentParser: The created subparser object.
        """
        parser = self.subparsers.add_parser(self.name, help=self.help_text)

        for arg_cfg in self.args_config:
            arg_names = arg_cfg.pop('name')
            parser.add_argument(*arg_names, **arg_cfg)

        parser.set_defaults(func=self.default_func)
        return parser


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# End of the SubcommandInitializer class
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
